__in bit Key[80];
__out bit KeyStream[128];

bit R[100];
bit S[100];

bit COMP0[100] = {0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0};
bit COMP1[100] = {0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0};
bit FB0[100] = {1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0};
bit FB1[100] = {1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};

define IVlength 32;
bit IV[IVlength] = {0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1};

int RTAPS[50] = {0, 1, 3, 4, 5, 6, 9, 12, 13, 16, 19, 20, 21, 22, 25, 28, 37, 38, 41, 42, 45, 46, 50, 52, 54, 56, 58, 60, 61, 63, 64, 65, 66, 67, 71, 72, 79, 80, 81, 82, 87, 88, 89, 90, 91, 92, 94, 95, 96, 97};

bit TMP_R[100];
bit TMP_S[100];
bit ADD_S[100];

bit IB_R;
bit CB_R;
bit IB_S;
bit CB_S;
bit IB;
bit MIXING;

void clock_r() {
  bit FB_R = R[99] ^ IB_R;

  /* SAVING OLD R */
  for(int v=0;v<100;v=v+1){
    TMP_R[v] = R[v];
  }

  /* SHIFTING */
  for (int o = 1; o < 100; o = o + 1) {
    R[o] = TMP_R[o-1];
  }

  R[0] = 0;

  for (int t = 0; t < 100; t = t + 1) {
    for (int j = 0; j < 50; j = j + 1) {
      if (t == RTAPS[j]) {
        R[t] = R[t] ^ FB_R;
      }
    }
  }

  if (CB_R == 1) {
    for (int r = 0; r < 100; r = r + 1) {
      R[r] = R[r] ^ TMP_R[r];
    }
  }
}

void clock_s() {
  bit FB_S = S[99] ^ IB_S;

  /* SAVING OLD S */
  for(int c=0;c<100;c = c + 1){
    TMP_S[c] = S[c];
    ADD_S[c] = S[c];
  }

  for (int e=1; e<99; e=e+1) {
    ADD_S[e] = TMP_S[e-1] ^ ((TMP_S[e] ^ COMP0[e]) & (TMP_S[e+1] ^ COMP1[e]));
  }

  ADD_S[0] = 0;
  ADD_S[99] = TMP_S[98];

  if (CB_S == 0) {
    for(int q = 0; q < 100; q = q + 1) {
      S[q] = ADD_S[q] ^ (FB0[q] & FB_S);
    }
  } else {
    for(int w = 0; w < 100; w = w + 1) {
      S[w] = ADD_S[w] ^ (FB1[w] & FB_S);
    }
  }
}

void clock_kg() {
  CB_R = S[34] ^ R[67];
  CB_S = S[67] ^ R[33];

  if (MIXING == 1) {
    IB_R = IB ^ S[50];
  } else {
    IB_R = IB;
  }

  IB_S = IB;

  clock_r();
  clock_s();
}

void main() {
  for(int h=0;h<100;h=h+1) {
    S[h] = 0;
    R[h] = 0;
  }

  for (int k=0; k < IVlength; k = k + 1) {
    IB = IV[k];
    MIXING = 1;
    clock_kg();
  }

  for (int m=0; m < 80; m = m + 1) {
    IB = Key[m];
    MIXING = 1;
    clock_kg();
  }

  for (int k=0; k < 100; k = k + 1) {
    IB = 0;
    MIXING = 1;
    clock_kg();
  }

  /*ENCODER*/
  for(int n = 0; n < 128; n = n + 1) {
    KeyStream[n] = R[0] ^ S[0];
    IB = 0;
    MIXING = 0;
    clock_kg();
  }

}
